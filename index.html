<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>Your deck.js Presentation</title>
  
  <!-- Required stylesheet -->
  <link rel="stylesheet" href="core/deck.core.css">
  
  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" href="extensions/goto/deck.goto.css">
  <link rel="stylesheet" href="extensions/menu/deck.menu.css">
  <link rel="stylesheet" href="extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" href="extensions/status/deck.status.css">
  <link rel="stylesheet" href="extensions/hash/deck.hash.css">
  <link rel="stylesheet" href="extensions/scale/deck.scale.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" href="themes/style/web-2.0.css">
  
  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" href="themes/transition/horizontal-slide.css">
  
  <!-- Required Modernizr file -->
  <script src="modernizr.custom.js"></script>

  <!-- SyntaxHighlighter -->
  <script type="text/javascript" src="syntaxhighlighter/scripts/shCore.js"></script>
  <script type="text/javascript" src="syntaxhighlighter/scripts/shBrushJScript.js"></script>
  <script type="text/javascript" src="syntaxhighlighter/scripts/shBrushScala.js"></script>
  <link type="text/css" rel="stylesheet" href="syntaxhighlighter/styles/shCoreDefault.css"/>
  <script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body class="deck-container">

<!-- Begin slides. Just make elements with a class of slide. -->













<!-- INTRO -->

<section class="slide">
  <h2>Error Handling in Scala</h2>
  <br>
  <h3>Yuvi Masory - <a href="https://twitter.com/ymasory">@ymasory</a></h3>
  <h3>Scala for Startups</h3>
  <h3>January 29, 2013</h3>
  <br>
  <br>
  <h3>Slides live at <a href="http://yuvimasory.com/talks">http://yuvimasory.com/talks</a>.</h3>
</section>


<!-- SECTION A: catch blocks. -->

<section class="slide">
  <h1>Section A:<br> Basic exception handling</h1>
</section>

<section class="slide">
  <h2>This section applies to Scala < 2.10.0/2.9.3</h2>
  <h3>
    Since Scala's try/catch blocks use pattern matching,
    this section is just a review of what patterns are available to you.
  </h3>
</section>

<section class="slide">
  <h2>Consider this function</h2>
<pre class="brush: scala;">
import scala.io.Source

def readFile(path: String) = (Source fromFile path).mkString()
</pre>
</section>

<section class="slide">
  <h2>A1. Catch an exception</h2>

  <pre class="brush: scala;">
import java.io.IOException

try {
  readFile("/opt/data")
}
catch {
  case e: IOException =>
}
  </pre>
</section>

<section class="slide">
  <h2>A2. Catching multiple types</h2>
  <pre class="brush: scala;">
import java.lang.NumberFormatException

try {
  readFile("/opt/social-security").toInt
}
catch {
  case e @ (_: IOException | _: NumberFormatException) =>
}
  </pre>
</section>

<section class="slide">
  <h2>A3. Subtyping exceptions</h2>
  <pre class="brush: scala;">
import java.nio.file.{ Files, FileSystemException, FileSystems }

try {
  val path = FileSystems.getDefault getPath "/opt/data"
  Files readAllBytes path
}
catch {
  // abstracting over:
  //   - java.nio.file.NoSuchFileExceptions
  //   - java.nio.file.NotDirectoryException
  //   - all other subclasses
  case e: FileSystemException =>
}
  </pre>
</section>

<section class="slide">
  <h2>A4. Catching exceptions by message</h2>
  <pre class="brush: scala;">
try {
  readFile("/opt/data").toInt
}
catch {
  case e: IOException if e.getMessage contains "Is a directory" =>
  case e: IOException =>
}
  </pre>
</section>

<section class="slide">
  <h2>A5. Catching all exceptions</h2>
  <pre class="brush: scala;">
try {
  readFile("/opt/data").toInt
}
catch {
  case e: Exception =>
}
  </pre>
</section>

<section class="slide">
  <h2>A6. DON'T DO THIS</h2>
  <pre class="brush: scala;">
try {
  readFile("/opt/data").toInt
}
catch {
  // this will match scala.util.control.ControlThrowable
  case _ =>
}
  </pre>
</section>

<section class="slide">
  <h2>A7. Catching "everything"</h2>
  <pre class="brush: scala;">
try {
  readFile("/opt/data").toInt
}
catch {
  case t: ControlThrowable => throw t
  case _                   =>
}
  </pre>
</section>



<!-- SECTION B: Exceptions not pure. -->

<section class="slide">
  <h1>Section B:<br> What's wrong with exceptions?</h1>
</section>

<section class="slide">
  <h2>Referential transparency</h2>
  <h3>Is there a value the RHS of this assignment can be replaced with?</h3>
  <pre class="brush: scala;">
    val a1: Nothing = sys error "foo"
  </pre>
  <h3>No.</h3>
  <h3>See <a href="http://www.manning.com/bjarnason/">Functional Programming in Scala</a>, chapter 4.</h3>
</section>


<section class="slide">
  <h1>Should I throw an exception?</h1>
</section>

<section class="slide">
  <ul>
    <li>
      <h3>Answer 1: No.</h3>
    </li>
    <li>
      <h3>Answer 2: If you're going to catch it, no.</h3>
    </li>
    <li>
     <h3>
        Answer 3: If you're going to catch it anywhere except the top-level "loop" of your application
        (E.g., Scalatra route handler, Play action, or Swing event loop), no.
      </h3>
    </li>
  </ul>
</section>



<!-- SECTION C: Try -->

<section class="slide">
  <h1>Section C:<br> Value-oriented exception handling</h1>
</section>

<section class="slide">
  <h2>This section applies to Scala >= 2.10.0/2.9.3</h2>
  <h3>When should you use these patterns over those in Section A?</h3>
  <h3>ALWAYS!</h3>
  <h3>Read this! <a href="http://www.iulidragos.org/?p=218">Abstracting exception handlers in Scala</a></h3>
</section>

<section class="slide">
  <h2>Try[A] (slightly simplified)</h2>
  <pre class="brush: scala;">
sealed trait Try[A]

case class Failure[A](e: Throwable) extends Try[A]

case class Success[A](value: A)     extends Try[A]
  </pre>
</section>

<section class="slide">
  <h2>C1. try/catch sans boilerplate</h2>
  <pre class="brush: scala;">
    import scala.util.Try

    def tryReadFile(path: String): Try[String] = Try {
      (Source fromFile path).mkString()
    }
  </pre>
</section>

<section class="slide">
  <h2>C2. Matching on Try</h2>
  <pre class="brush: scala;">
    tryReadFile("/opt/data") match {
      case Success(value) =>
      case Failure(e)     =>
    }
  </pre>
</section>


<section class="slide">
  <h2>C2.</h2>
  <pre class="brush: scala;">
  </pre>
</section>


<section class="slide">
  <h2>C2.</h2>
  <pre class="brush: scala;">
  </pre>
</section>



<!-- SECTION D: Option -->

<section class="slide">
  <h1>Section D:<br> Option[A]</h1>
</section>

<section class="slide">
  <h2>Option[A] (slightly simplified)</h2>
  <pre class="brush: scala;">
sealed trait Option[A]

case class Some[A](a: A) extends Option[A]

case object None         extends Option[Nothing]
  </pre>
</section>

<section class="slide">
  <h2>D1. Matching on Option</h2>
  <h2>(Option[A], Option[A] => B) => B</h2>
  <pre class="brush: scala;">
    val iOpt: Option[Int] = //...

    val sOpt: Option[String] = iOpt match {
      case Some(value) => value.toString
      case None        => ""
    }
  </pre>
</section>

<section class="slide">
   <h1>Stop matching on Option!!</h1>
</section>


<section class="slide">
   <h2>D2. Only consider Some</h2>
   <h2>(Option[A], A => B)) => Option[B]</h2>
  <pre class="brush: scala;">
    val sOpt: Option[String] = iOpt map { value => value.toString }

    val sOpt: Option[String] = iOpt map { _.toString }
  </pre>
</section>

<section class="slide">
   <h2>D3. More chances</h2>
  <h2>(Option[A], Option[A]) => Option[A]</h2>

  <pre class="brush: scala;">
    def foo(i: Int): Option[String]

    val sOpt: Option[String] =
      foo(1).orElse {
        foo(2).orElse {
          foo(3).orElse {
            foo(4)
          }
        }
      }
  </pre>
</section>

<section class="slide">
  <h2>D4. Consider both cases</h2>
  <h2>(Option[A], B, A => B)) => B</h2>

  <pre class="brush: scala;">
    val sOpt: Option[String] =
      iOpt.fold("") { _.toString }
  </pre>

</section>

<section class="slide">
  <h2>D5. Provide default value</h2>
  <h2>(Option[A], A) => A</h2>

  <pre class="brush: scala;">
    val i: Int = iOpt getOrElse 0
  </pre>
</section>

<section class="slide">
   <h2>D6. Monads! (flatmap)</h2>
   <h2>(Option[A], A => Option[B]) => Option[B]</h2>

  <pre class="brush: scala;">
    import scala.math.sqrt

    def perfectSqrt(i: Int): Option[Int] = {
      val root: Int = sqrt(i).toInt
      if (root * root == i) Some(root) else None
    }

    val i: Int = //...

    perfectSqrt(i).flatMap {
      perfectSqrt(_).flatMap {
        perfectSqrt(_)
      }
    }

  </pre>
</section>

<section class="slide">
   <h2>D7. Monads! (for-comprehensions)</h2>
   <h2>(Option[A], A => Option[B]) => Option[B]</h2>

  <pre class="brush: scala;">
    def triplePerfectSqrt(i: Int): Option[Int] = for {
      j <- perfectSqrt(i)
      k <- perfectSqrt(j)
      l <- perfectSqrt(k)
    } yield l
  </pre>
</section>

<section class="slide">
  <h2>D8. Are you there?</h2>
  <h2>Option[A] => Boolean</h2>

  <pre class="brush: scala;">
    val b1: Boolean = iOpt.isDefined

    val b2: Boolean = iOpt.isEmpty
  </pre>
</section>

<section class="slide">
   <h2>D9. Are you there and ...?</h2>
   <h2>(Option[A], A => Boolean) => Boolean</h2>

  <pre class="brush: scala;">
    val b1: Boolean = iOpt exists { _ > 0 }
  </pre>
</section>

<section class="slide">
   <h2>D10. Dealing with null</h2>
   <h2>A => Option[A]</h2>

  <pre class="brush: scala;">
    //MAY RETURN NULL
    def javaFunction(): String

    val sOpt: Option[String] = Option(javaFunction())
  </pre>
</section>

<section class="slide">
   <h2>D11. Only execute if all the Options are defined</h2>

  <pre class="brush: scala;">
    val iOpt: Option[Int] = //...
    val cOpt: Option[Char] = //...
    val dOpt: Option[Double] = //...

    val sOpt: Option[String] = for {
      i <- iOpt
      c <- cOpt
      d <- dOpt
    } yield s"$i$s$d"
  </pre>
</section>





<!-- SECTION E: Either -->

<section class="slide">
  <h1>Section E:<br> Either[E, A]</h1>
</section>

<section class="slide">
  <h2>Either[E, A] (slightly simplified)</h2>
  <pre class="brush: scala;">
sealed trait Either[E, A]

case class Left[E](e: E)  extends Either[E, A]

case class Right[A](a: A) extends Either[E, A]
  </pre>
</section>



<!-- SECTION F: ValidationNEL -->

<section class="slide">
  <h1>Section F:<br>Scalaz's Validation[E, A]</h1>
</section>

<section class="slide">
 <h2>Validation[E, A] (slightly simplified)</h2>
 <pre class="brush: scala;">
sealed trait Validation[E, A]

case class Success[E, A](a: A) extends Validation[E, A]

case class Failure[E, A](e: E) extends Validation[E, A]
  </pre>
</section>

<section class="slide">
  <h2>Validation[E, A] is very similar to Either[E, A]</h2>
  <h2>I won't repeat all the Either patterns.</h2>
  <h2>Caution:<br>syntax is in flux during the Scalaz 6 -> 7 rewrite.</h2>
  <h2>Also, Scalaz has some enhancements to Option & Either that are worth a look.</h2>
</section>

<section class="slide">
  <h2>Wouldn't it be nice if we could accumulate errors, instead of stopping on the first one?</h2>
  <h2>Read this! <a href="https://gist.github.com/970717">A Tale of 3 Night Clubs</a></h2>
</section>

<section class="slide">
  <h2>ValidationNEL (slightly simplified)</h2>
  <pre class="brush: scala;">
case class NonEmptyList[A](head: A, tail: List[A])

type ValidationNEL[E, A] = Validation[NonEmptyList[E], A]
  </pre>
</section>

<section class="slide">
 <h2>Consider this domain</h2>
 <pre class="brush: scala;">
class Person(age: Int, clothes: String, sober: Boolean, male: Boolean)

def checkAge(p: Person): Validation[String, Person] =
  if (p.age < 18) Failure("too young!") else Success(p)

def checkClothes(p: Person): Validation[String, Person] =
  if (p.clothes contains "jeans") Failure("dress up!")
  else Success(p)

def checkSobriety(p: Person): Validation[String, Person] =
  if (p.sober) Success(p) else Failure("sober up!")
  </pre>
</section>


<section class="slide">
 <h2>F1. Accumulate errors with applicative functors</h2>
 <pre class="brush: scala;">
def cost(p: Person): ValidationNEL[String, Int] = (
  checkAge(p).liftFailNel |@| 
  checkClothes(p).liftFailNel |@|
  checkSobriety(p).liftFailNel) {
    case (_, _, c) => if (c.male) 50 else 25
  }
 </pre>
</section>


<section class="slide">
  <h2>Pretty cool right?</h2>
  <h2>But what about a large (or unkown) number of checks?</h2>
</section>


<section class="slide">
  <h1>Aside:<br>type lambdas<br>(<em>aka</em> job security)</h1>
</section>


<section class="slide">
  <h2>Read this!
    <a href="http://stackoverflow.com/questions/8736164/what-are-type-lambdas-in-scala-and-what-are-their-benefits">
      What are type lambdas in Scala and what are their benefits?
    </a>
  </h2>
</section>

<section class="slide">
 <h2>Nominal types</h2>
 <pre class="brush: scala;">
trait Duck {
  def quack(): Unit
}
def foo(d: Duck) =
 </pre>

 <h2>Structural types</h2>
 <pre class="brush: scala;">
def foo(d: { def quack(): Unit }) =
 </pre>

 <h2>Duck "types" are structural types minus the static type system. (<em>I.e.</em>, runtime checking of compatability.)</h2>
</section>

<section class="slide">
 <h2>Example: how can we make <br>Either[E, A] conform to the Monad trait?</h2>
 <pre class="brush: scala;">
trait Monad[M[_]]

//Option is easy, since it only has one type parameter
class OptionMonad[A] extends Monad[Option]

//But what about Either? This won't compile.
class EitherMonad[A] extends Monad[Either]

//Neither will this.
class EitherMonad[A] extends Monad[Either[E]]
 </pre>
</section>

<section class="slide">
 <h2>Can types be partially applied, like functions?</h2>
 <h2>It was never intended, but it's possible with structural types!</h2>
 <pre class="brush: scala;">
//recall
trait Monad[M[_]]

//simple!
class EitherMonad[A]
  extends Monad[({type λ[α] = Either[A, α]})#λ] 
 </pre>
</section>

<section class="slide">
  <h1>Huh?</h1>
</section>

<section class="slide">
  <h2>Let's build that one up?</h2>
 <pre class="brush: scala;">
// structural type with no restrictions, equivalent to AnyRef
{}

// what do you know!
// the object defined by the structural type has a
// type alias of the type we're looking for!
{ type L[A] = Either[E, A] }

// reference the desired type directly
{ type L[A] = Either[E, A] }#L

// this looks vaguely like a lambda expression, so ...
{ type λ[α] = Either[E, α] }#λ
 </pre>
</section>

<section class="slide">
 <h2>Once again.</h2>
 <pre class="brush: scala;">
//recall
trait Monad[M[_]]

//simple!
class EitherMonad[A]
  extends Monad[({type λ[α] = Either[A, α]})#λ] 
 </pre>
 <h2>FYI: Type macros (part of Macro Paradise at present) will allow a nicer syntax.</h2>
</section>

<section class="slide">
  <h1>/Aside</h1>
</section>

<section class="slide">
 <h2>F2. Accumulate errors with traverse</h2>
 <pre class="brush: scala;">
def cost(p : Person) : ValidationNEL[String, Int] = {
  val checks = List(
    checkAge _,
    checkClothes _,
    checkSobriety _
  )
  checks.traverse[({type λ[α] = ValidationNEL[String, α]})#λ, Person](
    _ andThen (_.liftFailNel) apply p
  ) map {
    case c :: _ => if (c.male) 50 else 25
  }
}
 </pre>
</section>








<section class="slide">
  <h1>Aside:<br> Kleisli arrows</h1>
</section>



<!-- SECTION G: Box -->

<section class="slide">
  <h1>Section G:<br> Lift's Box[A]</h1>
</section>

<section class="slide">
  <h2>Box[A] (slightly simplified)</h2>
  <pre class="brush: scala;">
sealed trait Box[A]

case class Full[A](a: A) extends Box[A]

abstract class EmptyBox  extends Box[Nothing]

case class Failure(
  msg: String, e: Box[Throwable], chain: Box[Failure]
) extends EmptyBox

case class Empty extends EmptyBox
  </pre>
</section>

<section class="slide">
  <h2>Sorry! No time for Box.</h2>
  <h2>Take home message:<br> Box isn't as principled as Validation/NEL + Try, but check it out for an alternative way to accumulate errors.</h2>
</section>




<!-- THE END -->

<section class="slide">
  <h1>Phew!</h1>
  <h2>The end.</h2>
</section>

















<!-- End slides. -->


<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
  <span class="deck-status-current"></span>
  /
  <span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
  <label for="goto-slide">Go to slide:</label>
  <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
  <datalist id="goto-datalist"></datalist>
  <input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="jquery-1.7.2.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="core/deck.core.js"></script>
<script src="extensions/hash/deck.hash.js"></script>
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
  $(function() {
    $.deck('.slide');
  });
</script>
</body>
</html>
