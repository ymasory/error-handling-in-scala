<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>Your deck.js Presentation</title>
  
  <!-- Required stylesheet -->
  <link rel="stylesheet" href="core/deck.core.css">
  
  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" href="extensions/goto/deck.goto.css">
  <link rel="stylesheet" href="extensions/menu/deck.menu.css">
  <link rel="stylesheet" href="extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" href="extensions/status/deck.status.css">
  <link rel="stylesheet" href="extensions/hash/deck.hash.css">
  <link rel="stylesheet" href="extensions/scale/deck.scale.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" href="themes/style/web-2.0.css">
  
  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" href="themes/transition/horizontal-slide.css">
  
  <!-- Required Modernizr file -->
  <script src="modernizr.custom.js"></script>

  <!-- SyntaxHighlighter -->
  <script type="text/javascript" src="syntaxhighlighter/scripts/shCore.js"></script>
  <script type="text/javascript" src="syntaxhighlighter/scripts/shBrushJScript.js"></script>
  <script type="text/javascript" src="syntaxhighlighter/scripts/shBrushScala.js"></script>
  <link type="text/css" rel="stylesheet" href="syntaxhighlighter/styles/shCoreDefault.css"/>
  <script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body class="deck-container">

<!-- Begin slides. Just make elements with a class of slide. -->















<section class="slide">
  <h2>Error Handling in Scala</h2>
  <h3>Yuvi Masory - <a href="https://twitter.com/ymasory">@ymasory</a></h3>
  <h3>Scala for Startups</h3>
  <h3>January 29, 2013</h3>
</section>


<!-- SECTION A: catch blocks. -->

<section class="slide">
  <h1>Section A:<br> Basic exception handling</h1>
</section>

<section class="slide">
  <h2>This section applies to Scala < 2.10.0/2.9.3</h2>
  <h3>
    Since Scala's try/catch blocks use pattern matching,
    this section is just a review of what patterns are available to you.
  </h3>
</section>

<section class="slide">
  <h2>Consider this function</h2>
<pre class="brush: scala;">
import scala.io.Source

def readFile(path: String) = (Source fromFile path).mkString()
</pre>
</section>

<section class="slide">
  <h2>A1. Catch an exception</h2>

  <pre class="brush: scala;">
import java.io.IOException

try {
  readFile("/opt/data")
}
catch {
  case e: IOException =>
}
  </pre>
</section>

<section class="slide">
  <h2>A2. Catching multiple types</h2>
  <pre class="brush: scala;">
import java.lang.NumberFormatException

try {
  readFile("/opt/social-security").toInt
}
catch {
  case e @ (_: IOException | _: NumberFormatException) =>
}
  </pre>
</section>

<section class="slide">
  <h2>A3. Subtyping exceptions</h2>
  <pre class="brush: scala;">
import java.nio.file.{ Files, FileSystemException, FileSystems }

try {
  val path = FileSystems.getDefault getPath "/opt/data"
  Files readAllBytes path
}
catch {
  // abstracting over:
  //   - java.nio.file.NoSuchFileExceptions
  //   - java.nio.file.NotDirectoryException
  //   - all other subclasses
  case e: FileSystemException =>
}
  </pre>
</section>

<section class="slide">
  <h2>A4. Catching exceptions by message</h2>
  <pre class="brush: scala;">
try {
  readFile("/opt/data").toInt
}
catch {
  case e: IOException if e.getMessage contains "Is a directory" =>
  case e: IOException =>
}
  </pre>
</section>

<section class="slide">
  <h2>A5. Catching all exceptions</h2>
  <pre class="brush: scala;">
try {
  readFile("/opt/data").toInt
}
catch {
  case e: Exception =>
}
  </pre>
</section>

<section class="slide">
  <h2>A6. DON'T DO THIS</h2>
  <pre class="brush: scala;">
try {
  readFile("/opt/data").toInt
}
catch {
  // this will match scala.util.control.ControlThrowable
  case _ =>
}
  </pre>
</section>

<section class="slide">
  <h2>A7. Catching "everything"</h2>
  <pre class="brush: scala;">
try {
  readFile("/opt/data").toInt
}
catch {
  case t: ControlThrowable => throw t
  case _                   =>
}
  </pre>
</section>


<!-- SECTION B: Exceptions not pure. -->

<section class="slide">
  <h1>Section B:<br> What's wrong with exceptions?</h1>
</section>

<section class="slide">
  <h2>Referential transparency</h2>
  <h3>Is there a value the RHS of this assignment can be replaced with?</h3>
  <pre class="brush: scala;">
    val a1: Nothing = sys error "foo"
  </pre>
  <h3>No.</h3>
  <h3>See <a href="http://www.manning.com/bjarnason/">Functional Programming in Scala</a>, chapter 4</h3>
  <h3>... by Paul Chiusano and RÃºnar Bjarnason</h3>
</section>


<section class="slide">
  <h1>Should I throw an exception?</h1>
</section>

<section class="slide">
  <ul>
    <li>
      <h3>Answer 1: No.</h3>
    </li>
    <li>
      <h3>Answer 2: If you're going to catch it, no.</h3>
    </li>
    <li>
     <h3>
        Answer 3: If you're going to catch it anywhere except the top-level "loop" of your application
        (E.g., Scalatra route handler, Play action, or Swing event loop), no.
      </h3>
    </li>
  </ul>
</section>


<!-- SECTION C: Try -->

<section class="slide">
  <h1>Section C:<br> Value-oriented exception handling</h1>
</section>

<section class="slide">
  <h2>This section applies to Scala >= 2.10.0/2.9.3</h2>
  <h3>When should you use these patterns over those in Section A?</h3>
  <h3>ALWAYS!</h3>
</section>

<section class="slide">
  <h2>Try[A] (slightly simplified)</h2>
  <pre class="brush: scala;">
sealed trait Try[A]

case class Failure[A](e: Throwable) extends Try[A]

case class Success[A](value: A)     extends Try[A]
  </pre>
</section>

<section class="slide">
  <h2>C1. try/catch sans boilerplate</h2>
  <pre class="brush: scala;">
    import scala.util.Try

    def tryReadFile(path: String): Try[String] = Try {
      (Source fromFile path).mkString()
    }
  </pre>
</section>

<section class="slide">
  <h2>C2. Matching on Try</h2>
  <pre class="brush: scala;">
    tryReadFile("/opt/data") match {
      case Success(value) =>
      case Failure(e)     =>
    }
  </pre>
</section>


<section class="slide">
  <h2>C2.</h2>
  <pre class="brush: scala;">
  </pre>
</section>


<section class="slide">
  <h2>C2.</h2>
  <pre class="brush: scala;">
  </pre>
</section>






<!-- SECTION D: Option -->

<section class="slide">
  <h1>Section D:<br> scala.Option</h1>
</section>

<section class="slide">
  <h2>Option[A] (slightly simplified)</h2>
  <pre class="brush: scala;">
sealed trait Option[A]

case class Some[A](a: A) extends Option[A]

case object None         extends Option[Nothing]
  </pre>
</section>

<section class="slide">
  <h2>D1. Matching on Option</h2>
  <h2>Option[A] => B</h2>
  <pre class="brush: scala;">
    val iOpt: Option[Int] = //...

    val sOpt: Option[String] = iOpt match {
      case Some(value) => value.toString
      case None        => ""
    }
  </pre>
</section>

<section class="slide">
   <h1>Stop matching on Option!!</h1>
</section>


<section class="slide">
   <h2>D2. Only consider Some</h2>
   <h2>(Option[A], A => B)) => Option[B]</h2>
  <pre class="brush: scala;">
    val sOpt: Option[String] = iOpt map { value => value.toString }

    val sOpt: Option[String] = iOpt map { _.toString }
  </pre>
</section>

<section class="slide">
   <h2>D3. Only consider None</h2>
</section>

<section class="slide">
   <h2>D4. Consider both cases</h2>
</section>

<section class="slide">
   <h2>D5. Provide default value</h2>
   <h2>(Option[A], A) => A</h2>
  <pre class="brush: scala;">
    val i: Int = iOpt getOrElse 0
  </pre>
</section>

<section class="slide">
   <h2>D6. Try again if None</h2>
</section>

<section class="slide">
   <h2>D7. Flatmap!</h2>
   <h2>(Option[A], A => Option[B]) => Option[B]</h2>
</section>

<section class="slide">
   <h2>D8. Are you there?</h2>
   <h2>Option[A] => Boolean</h2>
</section>

<section class="slide">
   <h2>D9. Are you there and ...?</h2>
   <h2>(Option[A], A => Boolean) => Boolean</h2>
</section>


<!-- SECTION E: Either -->

<section class="slide">
  <h1>Section E:<br> scala.util.Either</h1>
</section>

<section class="slide">
  <pre class="brush: scala;">
sealed trait Either[E, A]
case class Left[E](e: E) extends Either[E, A]
case class Right[A](a: A) extends Either[E, A]
  </pre>
</section>


<!-- SECTION F: Box -->

<section class="slide">
  <h1>Section F:<br> net.liftweb.common.Box</h1>
</section>

<section class="slide">
  <pre class="brush: scala;">
sealed trait Box[A]

case class Full[A](a: A) extends Box[A]

abstract class EmptyBox extends Box[Nothing]
case class Failure(msg: String, e: Box[Throwable], chain: Box[Failure])
  extends EmptyBox
case class Empty extends EmptyBox
  </pre>
</section>


<!-- SECTION G: Validation -->

<section class="slide">
  <h2>Validation[A, B]</h2>
</section>

<section class="slide">
 <pre class="brush: scala;">
sealed trait Validation[E, A]
case class Success[E, A](a: A) extends Validation[E, A]
case class Failure[E, A](e: E) extends Validation[E, A]
  </pre>
</section>



<!-- SECTION G: ValidationNEL -->

<section class="slide">
  <h2>ValidationNEL[A, B]</h2>
</section>

<section class="slide">
 <pre class="brush: scala;">
type ValidationNEL[A, B] = Validation[NonEmptyList[A], B]
  </pre>
</section>

<section class="slide">
  <h2>Let's <em>accumulate</em> errors!</h2>
</section>

<section class="slide">
  <h1>Aside<br>type lambdas</h1>
</section>

<section class="slide">
  <h1>Aside<br> Kleisli arrows</h1>
</section>

<section class="slide">
  <h1>Phew!</h1>
  <h2>The end.</h2>
</section>





















<!-- End slides. -->


<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
  <span class="deck-status-current"></span>
  /
  <span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
  <label for="goto-slide">Go to slide:</label>
  <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
  <datalist id="goto-datalist"></datalist>
  <input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="jquery-1.7.2.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="core/deck.core.js"></script>
<script src="extensions/hash/deck.hash.js"></script>
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
  $(function() {
    $.deck('.slide');
  });
</script>
</body>
</html>
